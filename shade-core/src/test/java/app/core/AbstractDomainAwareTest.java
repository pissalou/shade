/*
 * Copyright (C) 2013 Pascal Mazars
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package app.core;

import app.commons.ReflectionUtils;
import org.joda.time.DateMidnight;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.*;

/**
 * Offers utility methods to create tests involving domain objects.
 */
public abstract class AbstractDomainAwareTest {
    /**
     * Contains all the autogenerated instances so we can retrieve later via {@link #same(Class entityClass)}.
     */
    protected static Map<Class<? extends PersistentObject>, LinkedList<? extends PersistentObject>> testCache = new HashMap<Class<? extends PersistentObject>, LinkedList<? extends PersistentObject>>();

//    public static <T extends PersistentObject> T create(Class<T> entityClass, Object... args) {
//        try {
//            if (args.length > 0) {
//                Class[] methodSignature = ReflectionUtils.argsToMethodSignature(args);
//                return entityClass.getConstructor(methodSignature).newInstance(args);
//            }
//            Constructor[] constructors = entityClass.getConstructors();
//            Arrays.sort(constructors, new MethodSignatureDescConstructorComparator());
//            T newInstance = (T) constructors[0].newInstance(argumentGenerator(constructors[0]));
//            cache(entityClass, newInstance);
//            return newInstance;
//        } catch (Exception e) {
//            throw new RuntimeException(e);
//        }
//    }

    /**
     * Generates an instances via Reflection API setting values to all fields.
     * @param entityClass
     * @param <T>
     * @return
     */
    public static <T extends PersistentObject> T create(Class<T> entityClass) {
        try {
            T newInstance = entityClass.newInstance();
            for (Field field : ReflectionUtils.getAllDeclaredFields(entityClass)) {
                field.setAccessible(true);
                field.set(newInstance, autogenerateValue(entityClass, field));
            }
            cache(entityClass, newInstance);
            return newInstance;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static Object autogenerateValue(Class<? extends PersistentObject> entityClass, Field field) {
        Class clazz = field.getType();
        if (field.getName().equalsIgnoreCase("ID")) {
            return null; // IMPORTANT
        }
        if (PersistentObject.class.isAssignableFrom(clazz)) {
            try {
                return same(clazz);
            } catch (IllegalArgumentException e) {
                return create(clazz);
            }
        } else if (clazz == Date.class) {
            return new DateMidnight().toDate();
        } else if (clazz == Integer.class) {
            return count(entityClass);
        } else if (clazz == String.class) {
            return field.getName() + entityClass.getSimpleName() + count(entityClass);
        } else {
            throw new RuntimeException(clazz + " not supported");
        }
    }

//    private static Object[] argumentGenerator(Constructor constructor) {
//        Collection<Object> args = new ArrayList<Object>();
//        for (Class paramType : constructor.getParameterTypes()) {
//            args.add(argumentGenerator(paramType));
//        }
//        return args.toArray();
//    }

//    private static Object argumentGenerator(Class clazz) {
//        if (PersistentObject.class.isAssignableFrom(clazz)) {
//            return create(clazz);
//        } else if (clazz == String.class) {
//            return "JUnitTest";
//        } else {
//            throw new RuntimeException(clazz + " not supported");
//        }
//    }

    private static <T extends PersistentObject> void cache(Class<T> entityClass, T instance) {
        if (testCache.containsKey(entityClass))
            ((Collection<T>) testCache.get(entityClass)).add(instance);
        else
            testCache.put(entityClass, new LinkedList<T>(Arrays.<T>asList(instance)));
    }

    /**
     * Retrieve the most recent instance in the cache.
     * @param entityClass the type of instance
     * @param <T>
     * @return the most recent instance
     * @throws IllegalArgumentException if no instance of this type has been cached previously.
     */
    protected static <T extends PersistentObject> T same(Class<T> entityClass) {
        try {
            return (T) testCache.get(entityClass).getLast();
        } catch (NullPointerException e) {
            throw new IllegalArgumentException(entityClass + " not cached yet.");
        }
    }

    protected static int count(Class<? extends PersistentObject> entityClass) {
        try {
            return testCache.get(entityClass).size();
        } catch (NullPointerException e) {
            return 0; //entityClass not cached yet
        }
    }

    private static class MethodSignatureDescConstructorComparator implements Comparator<Constructor> {

        public int compare(Constructor cons1, Constructor cons2) {
            return cons2.getParameterTypes().length - cons1.getParameterTypes().length;
        }
    }
}
